// Code generated by protoc-gen-go.
// source: chaincode.proto
// DO NOT EDIT!

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "google/protobuf"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ChainletSpec_Type int32

const (
	ChainletSpec_UNDEFINED ChainletSpec_Type = 0
	ChainletSpec_GOLANG    ChainletSpec_Type = 1
	ChainletSpec_NODE      ChainletSpec_Type = 2
)

var ChainletSpec_Type_name = map[int32]string{
	0: "UNDEFINED",
	1: "GOLANG",
	2: "NODE",
}
var ChainletSpec_Type_value = map[string]int32{
	"UNDEFINED": 0,
	"GOLANG":    1,
	"NODE":      2,
}

func (x ChainletSpec_Type) String() string {
	return proto.EnumName(ChainletSpec_Type_name, int32(x))
}

type ChaincodeMessage_Type int32

const (
	ChaincodeMessage_UNDEFINED  ChaincodeMessage_Type = 0
	ChaincodeMessage_REGISTER   ChaincodeMessage_Type = 1
	ChaincodeMessage_REGISTERED ChaincodeMessage_Type = 2
	ChaincodeMessage_REQUEST    ChaincodeMessage_Type = 3
	ChaincodeMessage_RESPONSE   ChaincodeMessage_Type = 4
)

var ChaincodeMessage_Type_name = map[int32]string{
	0: "UNDEFINED",
	1: "REGISTER",
	2: "REGISTERED",
	3: "REQUEST",
	4: "RESPONSE",
}
var ChaincodeMessage_Type_value = map[string]int32{
	"UNDEFINED":  0,
	"REGISTER":   1,
	"REGISTERED": 2,
	"REQUEST":    3,
	"RESPONSE":   4,
}

func (x ChaincodeMessage_Type) String() string {
	return proto.EnumName(ChaincodeMessage_Type_name, int32(x))
}

// Carries the URL where the chaincode resides and the chaincode version.
// TODO: Merge with ChainletIDentifier.
type ChainletID struct {
	Url     string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	Version string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (m *ChainletID) Reset()         { *m = ChainletID{} }
func (m *ChainletID) String() string { return proto.CompactTextString(m) }
func (*ChainletID) ProtoMessage()    {}

// Carries the chaincode function and its arguments.
type ChainletMessage struct {
	Function string   `protobuf:"bytes,1,opt,name=function" json:"function,omitempty"`
	Args     []string `protobuf:"bytes,2,rep,name=args" json:"args,omitempty"`
}

func (m *ChainletMessage) Reset()         { *m = ChainletMessage{} }
func (m *ChainletMessage) String() string { return proto.CompactTextString(m) }
func (*ChainletMessage) ProtoMessage()    {}

// Carries the chaincode function and its arguments.
type ChaincodeInvocation struct {
	ChainletSpec *ChainletSpec    `protobuf:"bytes,1,opt,name=chainletSpec" json:"chainletSpec,omitempty"`
	Message      *ChainletMessage `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *ChaincodeInvocation) Reset()         { *m = ChaincodeInvocation{} }
func (m *ChaincodeInvocation) String() string { return proto.CompactTextString(m) }
func (*ChaincodeInvocation) ProtoMessage()    {}

func (m *ChaincodeInvocation) GetChainletSpec() *ChainletSpec {
	if m != nil {
		return m.ChainletSpec
	}
	return nil
}

func (m *ChaincodeInvocation) GetMessage() *ChainletMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

// Carries the chaincode specification. This is the actual metadata required for
// defining a chaincode.
type ChainletSpec struct {
	Type       ChainletSpec_Type `protobuf:"varint,1,opt,name=type,enum=protos.ChainletSpec_Type" json:"type,omitempty"`
	ChainletID *ChainletID       `protobuf:"bytes,2,opt,name=chainletID" json:"chainletID,omitempty"`
	CtorMsg    *ChainletMessage  `protobuf:"bytes,3,opt,name=ctorMsg" json:"ctorMsg,omitempty"`
}

func (m *ChainletSpec) Reset()         { *m = ChainletSpec{} }
func (m *ChainletSpec) String() string { return proto.CompactTextString(m) }
func (*ChainletSpec) ProtoMessage()    {}

func (m *ChainletSpec) GetChainletID() *ChainletID {
	if m != nil {
		return m.ChainletID
	}
	return nil
}

func (m *ChainletSpec) GetCtorMsg() *ChainletMessage {
	if m != nil {
		return m.CtorMsg
	}
	return nil
}

// Specify the deployment of a chaincode.
// TODO: Define `codePackage`.
type ChainletDeploymentSpec struct {
	ChainletSpec *ChainletSpec `protobuf:"bytes,1,opt,name=chainletSpec" json:"chainletSpec,omitempty"`
	// Controls when the chaincode becomes executable.
	EffectiveDate *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=effectiveDate" json:"effectiveDate,omitempty"`
	CodePackage   []byte                     `protobuf:"bytes,3,opt,name=codePackage,proto3" json:"codePackage,omitempty"`
}

func (m *ChainletDeploymentSpec) Reset()         { *m = ChainletDeploymentSpec{} }
func (m *ChainletDeploymentSpec) String() string { return proto.CompactTextString(m) }
func (*ChainletDeploymentSpec) ProtoMessage()    {}

func (m *ChainletDeploymentSpec) GetChainletSpec() *ChainletSpec {
	if m != nil {
		return m.ChainletSpec
	}
	return nil
}

func (m *ChainletDeploymentSpec) GetEffectiveDate() *google_protobuf.Timestamp {
	if m != nil {
		return m.EffectiveDate
	}
	return nil
}

// TODO: Merge this with ChainletID.
type ChainletIdentifier struct {
	// URL for accessing the Chainlet, eg. https://github.com/user/SampleContract
	Url string `protobuf:"bytes,1,opt,name=Url" json:"Url,omitempty"`
}

func (m *ChainletIdentifier) Reset()         { *m = ChainletIdentifier{} }
func (m *ChainletIdentifier) String() string { return proto.CompactTextString(m) }
func (*ChainletIdentifier) ProtoMessage()    {}

// Used by the peer to identify the requesting chaincode and allows for proper
// access to state.
type ChainletRequestContext struct {
	Id *ChainletIdentifier `protobuf:"bytes,1,opt,name=Id" json:"Id,omitempty"`
}

func (m *ChainletRequestContext) Reset()         { *m = ChainletRequestContext{} }
func (m *ChainletRequestContext) String() string { return proto.CompactTextString(m) }
func (*ChainletRequestContext) ProtoMessage()    {}

func (m *ChainletRequestContext) GetId() *ChainletIdentifier {
	if m != nil {
		return m.Id
	}
	return nil
}

// Provided by the peer to the chaincode to identify the requesting chaincode
// and allow for proper access to state.
type ChainletExecutionContext struct {
	ChainletId *ChainletIdentifier        `protobuf:"bytes,1,opt,name=ChainletId" json:"ChainletId,omitempty"`
	Timestamp  *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=Timestamp" json:"Timestamp,omitempty"`
}

func (m *ChainletExecutionContext) Reset()         { *m = ChainletExecutionContext{} }
func (m *ChainletExecutionContext) String() string { return proto.CompactTextString(m) }
func (*ChainletExecutionContext) ProtoMessage()    {}

func (m *ChainletExecutionContext) GetChainletId() *ChainletIdentifier {
	if m != nil {
		return m.ChainletId
	}
	return nil
}

func (m *ChainletExecutionContext) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type ChaincodeMessage struct {
	Type      ChaincodeMessage_Type      `protobuf:"varint,1,opt,name=type,enum=protos.ChaincodeMessage_Type" json:"type,omitempty"`
	Timestamp *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	Payload   []byte                     `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *ChaincodeMessage) Reset()         { *m = ChaincodeMessage{} }
func (m *ChaincodeMessage) String() string { return proto.CompactTextString(m) }
func (*ChaincodeMessage) ProtoMessage()    {}

func (m *ChaincodeMessage) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func init() {
	proto.RegisterEnum("protos.ChainletSpec_Type", ChainletSpec_Type_name, ChainletSpec_Type_value)
	proto.RegisterEnum("protos.ChaincodeMessage_Type", ChaincodeMessage_Type_name, ChaincodeMessage_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for ChainletSupport service

type ChainletSupportClient interface {
	// Return the datetime.
	GetExecutionContext(ctx context.Context, in *ChainletRequestContext, opts ...grpc.CallOption) (*ChainletExecutionContext, error)
	Register(ctx context.Context, opts ...grpc.CallOption) (ChainletSupport_RegisterClient, error)
}

type chainletSupportClient struct {
	cc *grpc.ClientConn
}

func NewChainletSupportClient(cc *grpc.ClientConn) ChainletSupportClient {
	return &chainletSupportClient{cc}
}

func (c *chainletSupportClient) GetExecutionContext(ctx context.Context, in *ChainletRequestContext, opts ...grpc.CallOption) (*ChainletExecutionContext, error) {
	out := new(ChainletExecutionContext)
	err := grpc.Invoke(ctx, "/protos.ChainletSupport/GetExecutionContext", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainletSupportClient) Register(ctx context.Context, opts ...grpc.CallOption) (ChainletSupport_RegisterClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ChainletSupport_serviceDesc.Streams[0], c.cc, "/protos.ChainletSupport/Register", opts...)
	if err != nil {
		return nil, err
	}
	x := &chainletSupportRegisterClient{stream}
	return x, nil
}

type ChainletSupport_RegisterClient interface {
	Send(*ChaincodeMessage) error
	Recv() (*ChaincodeMessage, error)
	grpc.ClientStream
}

type chainletSupportRegisterClient struct {
	grpc.ClientStream
}

func (x *chainletSupportRegisterClient) Send(m *ChaincodeMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *chainletSupportRegisterClient) Recv() (*ChaincodeMessage, error) {
	m := new(ChaincodeMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ChainletSupport service

type ChainletSupportServer interface {
	// Return the datetime.
	GetExecutionContext(context.Context, *ChainletRequestContext) (*ChainletExecutionContext, error)
	Register(ChainletSupport_RegisterServer) error
}

func RegisterChainletSupportServer(s *grpc.Server, srv ChainletSupportServer) {
	s.RegisterService(&_ChainletSupport_serviceDesc, srv)
}

func _ChainletSupport_GetExecutionContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChainletRequestContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChainletSupportServer).GetExecutionContext(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _ChainletSupport_Register_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ChainletSupportServer).Register(&chainletSupportRegisterServer{stream})
}

type ChainletSupport_RegisterServer interface {
	Send(*ChaincodeMessage) error
	Recv() (*ChaincodeMessage, error)
	grpc.ServerStream
}

type chainletSupportRegisterServer struct {
	grpc.ServerStream
}

func (x *chainletSupportRegisterServer) Send(m *ChaincodeMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *chainletSupportRegisterServer) Recv() (*ChaincodeMessage, error) {
	m := new(ChaincodeMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ChainletSupport_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.ChainletSupport",
	HandlerType: (*ChainletSupportServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetExecutionContext",
			Handler:    _ChainletSupport_GetExecutionContext_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Register",
			Handler:       _ChainletSupport_Register_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}
