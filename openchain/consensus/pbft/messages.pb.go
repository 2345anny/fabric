// Code generated by protoc-gen-go.
// source: messages.proto
// DO NOT EDIT!

/*
Package pbft is a generated protocol buffer package.

It is generated from these files:
	messages.proto

It has these top-level messages:
	PBFT
	Request
	RequestHashes
	Requests
*/
package pbft

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type PBFT_Type int32

const (
	PBFT_UNDEFINED      PBFT_Type = 0
	PBFT_REQUEST        PBFT_Type = 1
	PBFT_PRE_PREPARE    PBFT_Type = 2
	PBFT_PREPARE        PBFT_Type = 3
	PBFT_COMMIT         PBFT_Type = 4
	PBFT_PREPARE_RESULT PBFT_Type = 5
	PBFT_COMMIT_RESULT  PBFT_Type = 6
)

var PBFT_Type_name = map[int32]string{
	0: "UNDEFINED",
	1: "REQUEST",
	2: "PRE_PREPARE",
	3: "PREPARE",
	4: "COMMIT",
	5: "PREPARE_RESULT",
	6: "COMMIT_RESULT",
}
var PBFT_Type_value = map[string]int32{
	"UNDEFINED":      0,
	"REQUEST":        1,
	"PRE_PREPARE":    2,
	"PREPARE":        3,
	"COMMIT":         4,
	"PREPARE_RESULT": 5,
	"COMMIT_RESULT":  6,
}

func (x PBFT_Type) String() string {
	return proto.EnumName(PBFT_Type_name, int32(x))
}

// PBFT is the common message type used to unmarshal the payload of an
// OpenchainMessage_CONSENSUS message.
//
// TODO: Define the contents when the type is REQUEST.
//
// When it's a "PRE_PREPARE", the "ID" field is set by the leader. The "payload"
// field is expected to contain an array of hashes corresponding to received
// "Request" messages. When the Type is "PREPARE_RESULT" or "COMMIT_RESULT",
// "payload" should carry the candidate global hash.
type PBFT struct {
	Type    PBFT_Type `protobuf:"varint,1,opt,name=type,enum=pbft.PBFT_Type" json:"type,omitempty"`
	ID      string    `protobuf:"bytes,2,opt,name=ID" json:"ID,omitempty"`
	Payload []byte    `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *PBFT) Reset()         { *m = PBFT{} }
func (m *PBFT) String() string { return proto.CompactTextString(m) }
func (*PBFT) ProtoMessage()    {}

// Request is the message passed by the peer to the validator.
// The peer receives a client request to deploy or invoke a chaincode, assigns
// it a unique ID, then packages into a "Request" message that is passed along
// to one of its connected validators.
type Request struct {
	ID      string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}

// RequestHashes contains the hashes of the "Request" messages that the leader
// will package in a consensus round. Marshalling such a message (proto.Marshal)
// should generate the "payload" of a PRE_PREPARE message (see "Phase" message).
type RequestHashes struct {
	Hashes []string `protobuf:"bytes,1,rep,name=hashes" json:"hashes,omitempty"`
}

func (m *RequestHashes) Reset()         { *m = RequestHashes{} }
func (m *RequestHashes) String() string { return proto.CompactTextString(m) }
func (*RequestHashes) ProtoMessage()    {}

// Requests will be used temporarily instead of RequestHashes. In order to use
// "RequestHashes", a datastore is needed on every validator that maps incoming
// "Request" messages to their hashes. Until this structure is implemented, the
// leader should proto.Marshal() a "Requests" message for a PRE_PREPARE
// message's "payload".
type Requests struct {
	Requests []*Request `protobuf:"bytes,1,rep,name=requests" json:"requests,omitempty"`
}

func (m *Requests) Reset()         { *m = Requests{} }
func (m *Requests) String() string { return proto.CompactTextString(m) }
func (*Requests) ProtoMessage()    {}

func (m *Requests) GetRequests() []*Request {
	if m != nil {
		return m.Requests
	}
	return nil
}

func init() {
	proto.RegisterEnum("pbft.PBFT_Type", PBFT_Type_name, PBFT_Type_value)
}
