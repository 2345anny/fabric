// Code generated by protoc-gen-go.
// source: eventhub.proto
// DO NOT EDIT!

/*
Package protos is a generated protocol buffer package.

It is generated from these files:
	eventhub.proto

It has these top-level messages:
	InterestedEvent
	RegisterEvent
	TransactionEvent
	GenericEvent
	EventHubMessage
*/
package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type InterestedEvent_ResponseType int32

const (
	// send objects
	InterestedEvent_NATIVE InterestedEvent_ResponseType = 0
	// marshall into JSON byte array
	InterestedEvent_JSON InterestedEvent_ResponseType = 1
	// don't send events (used to cancel interest)
	InterestedEvent_DONTSEND InterestedEvent_ResponseType = 2
)

var InterestedEvent_ResponseType_name = map[int32]string{
	0: "NATIVE",
	1: "JSON",
	2: "DONTSEND",
}
var InterestedEvent_ResponseType_value = map[string]int32{
	"NATIVE":   0,
	"JSON":     1,
	"DONTSEND": 2,
}

func (x InterestedEvent_ResponseType) String() string {
	return proto.EnumName(InterestedEvent_ResponseType_name, int32(x))
}

type GenericEvent_Encoding int32

const (
	// just bytes - bytesType should be used to convey type information
	GenericEvent_RAW GenericEvent_Encoding = 0
	// json encoding - bytesType could be used for additional type information
	GenericEvent_JSON GenericEvent_Encoding = 1
	// string encoding- bytesType could be used for additional type information
	GenericEvent_STRING GenericEvent_Encoding = 2
)

var GenericEvent_Encoding_name = map[int32]string{
	0: "RAW",
	1: "JSON",
	2: "STRING",
}
var GenericEvent_Encoding_value = map[string]int32{
	"RAW":    0,
	"JSON":   1,
	"STRING": 2,
}

func (x GenericEvent_Encoding) String() string {
	return proto.EnumName(GenericEvent_Encoding_name, int32(x))
}

type InterestedEvent struct {
	EventType    string                       `protobuf:"bytes,1,opt,name=eventType" json:"eventType,omitempty"`
	ResponseType InterestedEvent_ResponseType `protobuf:"varint,2,opt,name=responseType,enum=protos.InterestedEvent_ResponseType" json:"responseType,omitempty"`
}

func (m *InterestedEvent) Reset()         { *m = InterestedEvent{} }
func (m *InterestedEvent) String() string { return proto.CompactTextString(m) }
func (*InterestedEvent) ProtoMessage()    {}

// ---------- consumer events ---------
// RegisterEvent is sent by consumers for registering events
// string type - "register"
type RegisterEvent struct {
	Events []*InterestedEvent `protobuf:"bytes,1,rep,name=events" json:"events,omitempty"`
}

func (m *RegisterEvent) Reset()         { *m = RegisterEvent{} }
func (m *RegisterEvent) String() string { return proto.CompactTextString(m) }
func (*RegisterEvent) ProtoMessage()    {}

func (m *RegisterEvent) GetEvents() []*InterestedEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

// ---------- producer events ---------
// TransactionEvent is sent when a transaction is executed
// string type - "transaction"
type TransactionEvent struct {
	UUID    string `protobuf:"bytes,1,opt,name=UUID" json:"UUID,omitempty"`
	Success bool   `protobuf:"varint,2,opt,name=success" json:"success,omitempty"`
	Payload []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *TransactionEvent) Reset()         { *m = TransactionEvent{} }
func (m *TransactionEvent) String() string { return proto.CompactTextString(m) }
func (*TransactionEvent) ProtoMessage()    {}

// GenericEvent is used for encoding payload as bytes
// string type - "generic"
type GenericEvent struct {
	Encoding  GenericEvent_Encoding `protobuf:"varint,1,opt,name=encoding,enum=protos.GenericEvent_Encoding" json:"encoding,omitempty"`
	BytesType string                `protobuf:"bytes,2,opt,name=bytesType" json:"bytesType,omitempty"`
	Payload   []byte                `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *GenericEvent) Reset()         { *m = GenericEvent{} }
func (m *GenericEvent) String() string { return proto.CompactTextString(m) }
func (*GenericEvent) ProtoMessage()    {}

// EventHubMessage is used by
//  - consumers (adapters) to send Register
//  - producer to advertise supported types and events
type EventHubMessage struct {
	// Types that are valid to be assigned to Event:
	//	*EventHubMessage_RegisterEvent
	//	*EventHubMessage_TransactionEvent
	//	*EventHubMessage_GenericEvent
	Event isEventHubMessage_Event `protobuf_oneof:"Event"`
}

func (m *EventHubMessage) Reset()         { *m = EventHubMessage{} }
func (m *EventHubMessage) String() string { return proto.CompactTextString(m) }
func (*EventHubMessage) ProtoMessage()    {}

type isEventHubMessage_Event interface {
	isEventHubMessage_Event()
}

type EventHubMessage_RegisterEvent struct {
	RegisterEvent *RegisterEvent `protobuf:"bytes,2,opt,name=registerEvent,oneof"`
}
type EventHubMessage_TransactionEvent struct {
	TransactionEvent *TransactionEvent `protobuf:"bytes,3,opt,name=transactionEvent,oneof"`
}
type EventHubMessage_GenericEvent struct {
	GenericEvent *GenericEvent `protobuf:"bytes,4,opt,name=genericEvent,oneof"`
}

func (*EventHubMessage_RegisterEvent) isEventHubMessage_Event()    {}
func (*EventHubMessage_TransactionEvent) isEventHubMessage_Event() {}
func (*EventHubMessage_GenericEvent) isEventHubMessage_Event()     {}

func (m *EventHubMessage) GetEvent() isEventHubMessage_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *EventHubMessage) GetRegisterEvent() *RegisterEvent {
	if x, ok := m.GetEvent().(*EventHubMessage_RegisterEvent); ok {
		return x.RegisterEvent
	}
	return nil
}

func (m *EventHubMessage) GetTransactionEvent() *TransactionEvent {
	if x, ok := m.GetEvent().(*EventHubMessage_TransactionEvent); ok {
		return x.TransactionEvent
	}
	return nil
}

func (m *EventHubMessage) GetGenericEvent() *GenericEvent {
	if x, ok := m.GetEvent().(*EventHubMessage_GenericEvent); ok {
		return x.GenericEvent
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EventHubMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _EventHubMessage_OneofMarshaler, _EventHubMessage_OneofUnmarshaler, []interface{}{
		(*EventHubMessage_RegisterEvent)(nil),
		(*EventHubMessage_TransactionEvent)(nil),
		(*EventHubMessage_GenericEvent)(nil),
	}
}

func _EventHubMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EventHubMessage)
	// Event
	switch x := m.Event.(type) {
	case *EventHubMessage_RegisterEvent:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RegisterEvent); err != nil {
			return err
		}
	case *EventHubMessage_TransactionEvent:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TransactionEvent); err != nil {
			return err
		}
	case *EventHubMessage_GenericEvent:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GenericEvent); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EventHubMessage.Event has unexpected type %T", x)
	}
	return nil
}

func _EventHubMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EventHubMessage)
	switch tag {
	case 2: // Event.registerEvent
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RegisterEvent)
		err := b.DecodeMessage(msg)
		m.Event = &EventHubMessage_RegisterEvent{msg}
		return true, err
	case 3: // Event.transactionEvent
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TransactionEvent)
		err := b.DecodeMessage(msg)
		m.Event = &EventHubMessage_TransactionEvent{msg}
		return true, err
	case 4: // Event.genericEvent
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenericEvent)
		err := b.DecodeMessage(msg)
		m.Event = &EventHubMessage_GenericEvent{msg}
		return true, err
	default:
		return false, nil
	}
}

func init() {
	proto.RegisterEnum("protos.InterestedEvent_ResponseType", InterestedEvent_ResponseType_name, InterestedEvent_ResponseType_value)
	proto.RegisterEnum("protos.GenericEvent_Encoding", GenericEvent_Encoding_name, GenericEvent_Encoding_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for EventHub service

type EventHubClient interface {
	// event chatting using EventHubMessage
	Chat(ctx context.Context, opts ...grpc.CallOption) (EventHub_ChatClient, error)
}

type eventHubClient struct {
	cc *grpc.ClientConn
}

func NewEventHubClient(cc *grpc.ClientConn) EventHubClient {
	return &eventHubClient{cc}
}

func (c *eventHubClient) Chat(ctx context.Context, opts ...grpc.CallOption) (EventHub_ChatClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EventHub_serviceDesc.Streams[0], c.cc, "/protos.EventHub/Chat", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventHubChatClient{stream}
	return x, nil
}

type EventHub_ChatClient interface {
	Send(*EventHubMessage) error
	Recv() (*EventHubMessage, error)
	grpc.ClientStream
}

type eventHubChatClient struct {
	grpc.ClientStream
}

func (x *eventHubChatClient) Send(m *EventHubMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *eventHubChatClient) Recv() (*EventHubMessage, error) {
	m := new(EventHubMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for EventHub service

type EventHubServer interface {
	// event chatting using EventHubMessage
	Chat(EventHub_ChatServer) error
}

func RegisterEventHubServer(s *grpc.Server, srv EventHubServer) {
	s.RegisterService(&_EventHub_serviceDesc, srv)
}

func _EventHub_Chat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventHubServer).Chat(&eventHubChatServer{stream})
}

type EventHub_ChatServer interface {
	Send(*EventHubMessage) error
	Recv() (*EventHubMessage, error)
	grpc.ServerStream
}

type eventHubChatServer struct {
	grpc.ServerStream
}

func (x *eventHubChatServer) Send(m *EventHubMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *eventHubChatServer) Recv() (*EventHubMessage, error) {
	m := new(EventHubMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _EventHub_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.EventHub",
	HandlerType: (*EventHubServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Chat",
			Handler:       _EventHub_Chat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}
